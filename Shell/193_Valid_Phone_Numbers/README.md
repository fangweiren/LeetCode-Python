题意  
给定一个文本文件file.txt，包含一列电话号码（每行一个），写一个单行bash脚本输出全部有效的电话号码。  
你可以假设有效的电话号码符合下列两种格式之一：(xxx) xxx-xxxx or xxx-xxx-xxxx. (x 代表数字)  
同时也可以假设文本文件中的每一行都不包含前导或者后缀空格。  
例如，假设file.txt包含下面的内容：

    987-123-4567
    123 456 7890
    (123) 456-7890
    
你的脚本应该输出下列有效的电话号码：

    987-123-4567
    (123) 456-7890

思路：  
用正则来匹配需要的格式显示输出

方法一：  
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt

'/.../'表示中间的是要匹配的正则表达式，然后字符^匹配一行的开头，美元符$在正则表达式中匹配行尾，然后再看中间的部分，[0-9]{3}表示匹配三个数字，圆括号括起一组正则表达式. 它和"|"操作符或在用expr进行子字符串提取(substring extraction)一起使用很有用。那么([0-9]{3}-|[0−9]3 )就可以理解了，它匹配了xxx-和(xxx) 这两种形式的字符串，然后后面的就好理解了，匹配xxx-xxxx这样的字符串。

方法二：  
sed -n -r '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p' file.txt

-n表示关闭默认输出，默认将自动打印所有行，这样就不会打印出不符合要求的数字串了。-r表示支持扩展正则+ ? () {} |。后面的正则表达式和上面都相同，就是后面多了一个p，在用sed时，p和-n合用，表示打印某一行，这样才能把符合要求的行打印出来。

方法三：  
grep -P '^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$' file.txt

-P 选项是利用PERL的正则语法进行匹配；-o 是仅匹配这样的模式；上面的参数可以把-P变成-Po，结果也是被接受。
